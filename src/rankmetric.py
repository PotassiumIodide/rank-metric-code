import numpy as np
from itertools import combinations
from typing import List, Tuple, Union

from .nary import all_nary
from .type_def import prime, Codeword, Code

INFINITY = 9999999

def linear_space_spanned_by(bases: List[Codeword], p: prime) -> Code:
    """
    Return a linear subspace over Fp spanned by given bases.

    Arguments:
    bases: {List[numpy.ndarray]} - A set of codeword
    p    : {int}                 - A prime number

    Returns:
    {List[numpy.ndarray]} - A linear space spanned by given bases.
    """
    B, l = bases, len(bases)
    n, m = B[0].shape
    space = []
    for lincomb in all_nary(2, l):
        mat = np.array([0]*(n*m)).reshape(n,m)
        for i in range(l):
            mat += lincomb[i] * B[i]
        space.append(np.mod(mat, p))
    return [*map(
        lambda t: np.array(t).reshape(n,m),
        list( {*map(lambda c: tuple(c.flatten()), space)} )
        )
    ]


def wt(C: Codeword) -> int:
    """
    Return the rank-weight of a codeword of some rank-metric code

    Arguments:
    C: {np.ndarray} - A codeword of some rank-metric code

    Returns:
    {int} - rank-weight
    """
    return np.linalg.matrix_rank(C)


def pseudo_generator_matrix(bases: List[Codeword]) -> np.ndarray:
    """
    Give a representation of a generator matrix of a rank-metric code.

    Arguments:
    bases: {List[numpy.ndarray]} - A base of a rank-metric code

    Returns:
    {numpy.ndarray} - A representation of a pseudo generator matrix of a rank-metric code
    """
    return np.array([base.flatten() for base in bases])


def pseudo_code_generated_by(bases: List[Codeword], p:prime) -> List[np.ndarray]:
    """
    Treat a rank-metric code over Fp as if it is a normal linear code over Fp

    Arguments:
    bases: {List[numpy.ndarray]} - A base of a rank-metric code
    p    : {int}                 - A prime number for Fp

    Returns:
    {List[numpy.ndarray]} - A pseudo representation of a rank-metric code
    """
    G = pseudo_generator_matrix(bases)
    return [*map(
        lambda t: np.array(t),
        list( { tuple(np.mod(lincomb @ G, p)) for lincomb in all_nary(p, len(bases)) } )
    )] if list(G) else []


def code_from_pseudo_code(pseudo_code: List[np.array], rows: int, cols: int) -> Code:
    """
    Transform a pseudo-code into normal rank-metric code

    Arguments:
    pseudo_code: {List[numpy.ndarray]} - A pseudo representation of a rank-metric code
    rows: {int} - The number of row vectors in a rank-metric code
    cols: {int} - The number of column vectors in a rank-metric code

    Returns:
    {List[numpy.ndarray]} - A rank-metric code
    """
    return [*map(
        lambda c_: c_.reshape(rows, cols),
        pseudo_code
        )
    ]


def col(C: Codeword, p: prime) -> List[np.ndarray]:
    """
    Return the column space over Fp generated from the given codeword

    Arguments:
    C: {numpy.ndarray} - A codeword for generating a column space
    p: {int}           - A prime number for Fp

    Returns:
    {List[numpy.ndarray]} - The column space over Fp generated by the column vectors in a given matrix C
    """
    return pseudo_code_generated_by(
        np.array(list(
            { *map(tuple, list(C.T)) } - { tuple([0] * C.shape[0]) } # faster calculation
            # C.T
        )), p )


def cols(matrices: List[np.ndarray], p: prime) -> List[np.ndarray]:
    """
    Return the direct sum of column spaces over Fp spanned by given matrices.

    Arguments:
    matrices: {List[numpy.ndarray]} - Matrices for spanning the column space
    p       : {int}                 - A prime number for Fp

    Returns:
    {List[np.ndarray]} - Vector space given by the direct sum of column spaces spanned by given matrices
    """
    return direct_sum(map(lambda b: col(b,p), matrices), p)


def direct_sum(Vs: List[np.ndarray], p: prime) -> List[np.ndarray]:
    """
    Return the direct sum of given vector spaces over Fp.

    Arguments:
    Vs: {List[numpy.ndarray]} - A set of Vector spaces over Fp
    p : {int}                 - A prime number for Fp

    Returns:
    {List[numpy.ndarray]} - The direct sum of vector spaces over Fp
    """
    return pseudo_code_generated_by(
        np.array(list({*map(tuple, sum(Vs, []))}))
    , p)


def gamma(C: Code, p: prime, get_evidence: bool=False) -> Union[int, Tuple[int, Tuple[np.ndarray]]]:
    """
    Calculate the covering dimension of a rank-metric code.
    γ(C) := min{r∈Z+:∃D≤C, dimD=r, ⊕[M∈D]col(M)=Fp^n}

    Arguments:
    C: {List[numpy.ndarray]} - A rank-metric code
    p: {int}                 - A prime number for Fp

    Returns:
    {Union[int, (int, List[numpy.ndarray]])}
    -- If get_evidence is true,
        {int} - The covering dimension of a given rank-metric code
    -- otherwise,
        {(int, Tuple[numpy.ndarray])} - The tuple of γ(C) and a codeword covering Fp^m
    """
    criteria = p ** C[0].shape[0] # The number of all vectors in Fp^k
    for r in range(len(C)):
        for cwds in combinations(C, r):
            # Judge if the direct sum of colmun spaces could cover, according to identification to criteria
            if len(direct_sum(map(lambda cwd: col(cwd, p), cwds), p)) == criteria:
                if get_evidence:
                    return (r, cwds)
                return r
    if get_evidence:
        return (INFINITY, tuple([]))
    return INFINITY # Representation of infinity